const commonUtils = require('./common-utils.js');

/**
 * These were determined by running multiple simulations with
 * different team averages and standard deviations and doing
 * a polynomial regression. These coefficents are generated by
 * a test in the softball-sim repository.
 *
 * For the coefficents, the regression is not quite exponential and I don't remember enough from
 * math or stats class to say what is exactly. So we just use
 * a polynomial regression of a high degree to force the regression
 * to fit our data.
 *
 * Twice the number of cores doesn't result in twice the compute speed. There is
 * some error. Since every machine is different (core count, hyperthreading, etc..)
 * We generate average error values for running the optimization with differnt
 * core counts on applicable hardware and apply the error to the calculated result.
 * These values can also be determined by running a test in the softball-sim repository.
 */
let config = {
  iterations: 100,
  innings: 7,
  threads: 1,
  lineupType: 1,
  lineupCount: 40320,
  coefficients: [
    642.1831059773589,
    1764.0244987370788,
    54033.74469586498,
    -995890.536678744,
    8192458.368238615,
    -3.731949262576924e7,
    1.0277562517449364e8,
    -1.752081763647162e8,
    1.8073143058462426e8,
    -1.0328391915384695e8,
    2.508880476785901e7,
  ],
  errorAdjustments: [
    0.0,
    1.0,
    1.0101888330389892,
    1.018748726309354,
    1.0700991713082462,
    1.2158627717391304,
    1.2531078051762787,
    1.3074179743223966,
    1.4195652173913043,
    1.5331702843167228,
    1.698029891304348,
    1.9413303437967115,
    2.0619649408887075,
  ],
};

exports.estimateOptimizationTime = function(
  numLineups,
  coreCount,
  iterations,
  innings,
  teamAverage
) {
  let x = teamAverage;
  let y = 0;
  for (let i = 0; i < config.coefficients.length; i++) {
    let coeff = config.coefficients[i];
    y = y + coeff * Math.pow(x, i);
  }
  // Adjustments

  // Adjust for CPU core count (inverse relationship)
  if (coreCount == 0) {
    return Number.MAX_VALUE;
  }
  y *= config.threads / coreCount;
  y *= config.errorAdjustments[coreCount];

  // Adjust for number of iterations
  y *= iterations / config.iterations;

  // Adjust for number of innings simulated
  y *= innings / config.innings;

  // Adjust for number for lineups
  y *= numLineups / config.lineupCount;

  // We want the time in seconds (y is in milliseconds)
  return Math.round(y / 1000);
};

// TODO: at some point we'll need to have different classes for each of these lineupTypes to contain this logic
exports.getNumberOfPossibleLineups = function(
  lineupType,
  maleCount,
  femaleCount
) {
  let numberOfLineups = 0;
  if (lineupType == 1) {
    numberOfLineups = commonUtils.factorial(maleCount + femaleCount);
  } else if (lineupType == 2) {
    numberOfLineups =
      commonUtils.factorial(maleCount) * commonUtils.factorial(femaleCount);
  } else if (lineupType == 3) {
    // All three of these cases are invalid and won't be processed on the server anyways,
    if (femaleCount < 0) {
      // No females? Then it's just a normal lineup for the men
      return commonUtils.factorial(maleCount);
    }
    if (maleCount < 0) {
      // No males? If there is one female than there is one possible lineup. If there are any other number of females there are 0 possible lineups.
      // That difference doesn't matter much for time estimation purposes.
      return 1;
    }
    if (maleCount <= femaleCount) {
      // There are no lineups where females don't bat back-to-back
      return 0;
    }

    numberOfLineups =
      commonUtils.factorial(maleCount) *
      commonUtils.factorial(femaleCount) *
      (commonUtils.binomial(maleCount, femaleCount) +
        commonUtils.binomial(maleCount - 1, femaleCount - 1));
  } else {
    throw new Error(`Unrecognized lineup type ${lineupType}`);
  }
  return numberOfLineups;
};

exports.getCoreCount = function() {
  return 8;
};
